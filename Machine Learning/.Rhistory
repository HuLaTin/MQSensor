dev.off()
#d3heatmap or heatmaply
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 300)
heatMap <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "HeatMap.png", sep="-")
png(paste(output, heatMap, sep = "/"), width = 1600, height = 1200)
print(heatmap(eventHeat[,], main = paste(z, "Heat Map"),col=my_palette))
#print(heatmap(eventDF[,150:210], main = paste(z, "Heat Map")))
dev.off()
}
list[[y]] <- nrow(events[grep(y, rownames(events)), ])
#dat <- nrow(events[grep(y, rownames(events)), ])
}
dsNum <- min(unlist(list))
if (dsNum <= 1){
next
}
dsData <- data.frame()
for (y in chems) {
print(y)
idx_chem <- events[grep(y, rownames(events)), ]
idx_chem["pred"] <- as.factor(y)
data <- sample_n(idx_chem, dsNum)
dsData <- rbind(dsData, data)
}
dsData <- dsData[,c(ncol(dsData),1:(ncol(dsData)-1))]
### Need to build training and test sets ###
#this is broken...
sample = sample.split(dsData$pred, SplitRatio = .7)
train = subset(data, sample == TRUE)
test  = subset(data, sample == FALSE)
stop()
}
for (i in eventList)
{
events <- get(i)
if (i == "eventsTrim") {
desired_length <- length(chems)
list <- vector(mode = "list", length = desired_length)
for (y in chems){
list[[y]] <- nrow(events[grep(y, rownames(events)), ])
#dat <- nrow(events[grep(y, rownames(events)), ])
}
dsNum <- min(unlist(list))
if (dsNum <= 1){
next
}
dsData <- data.frame()
for (y in chems) {
#print(y)
idx_chem <- events[grep(y, rownames(events)), ]
idx_chem["pred"] <- as.factor(y)
data <- sample_n(idx_chem, dsNum)
dsData <- rbind(dsData, data)
}
dsData <- dsData[,c(ncol(dsData),1:(ncol(dsData)-1))]
### Need to build training and test sets ###
#this is broken...
sample = sample.split(dsData$pred, SplitRatio = .7)
train = subset(data, sample == TRUE)
test  = subset(data, sample == FALSE)
stop()
##### Naive Bayes Test ######
##### Need to balance sets ####
# nbModel <- naiveBayes(pred ~., data = dsData)
# nbPredict <- predict(nbModel, test[,-1])
# table(pred=nbPredict,true=eventDF$Event)
#
# confusionMatrix(nbPredict, eventDF$Event)
### Decision Tree ###
### also awaiting balanced sets ###
### this S#its gonna be so tight when it works ###
# tree <- rpart(pred ~ .,
#               data = dsData,
#               method = "class")
#
# rpart.plot(tree, nn=TRUE)
#
# #probably need to remove column by name instead
# treePredict <- predict(object=tree,dsData[-1],type="class")
#
# table(treePredict, dsData$pred)
#
# confusionMatrix(treePredict, dsData$pred)
}
eventDF <- events
eventHeat <- as.matrix(eventDF)
k <- round(sqrt(nrow(eventDF)))
#print(k)
#km.res <- kmeans(eventDF, k, nstart = 25)
##########################################nstart???
if (kSwitch == TRUE){
# K-Means Cluster Analysis
km.res <- kmeans(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
} else {
# K-means with pam()
km.res <- pam(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
}
#####################################################################
# Ward Hierarchical Clustering
distance <- dist(eventDF, method = "euclidean") # distance matrix
fit <- hclust(distance, method="ward.D2")
groups <- cutree(fit, k)
# Events <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), "Events.csv", sep="-")
# write.csv(events, paste(output, Events, sep = "/"),)
dendro <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "Dendrogram.png", sep="-")
png(paste(output, dendro, sep = "/"), width = 1200, height = 600)
plot(fit, main = paste(toString(z), toString(ExpectedChange), toString(windowSize), "Dendrogram","| Clusters:", toString(k), sep=" "))
#groups <- cutree(fit, k)
rect.hclust(fit, k, border="red")
dev.off()
#km.res <- kmeans(eventDF, k, nstart = 25)
fvizclust<- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "FvizCluster.png", sep="-")
png(paste(output, fvizclust, sep = "/"), width = 800, height = 800)
print(fviz_cluster(km.res, eventDF, main = paste(z, "Cluster Plot", "| Clusters:", toString(k))))
dev.off()
#d3heatmap or heatmaply
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 300)
heatMap <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "HeatMap.png", sep="-")
png(paste(output, heatMap, sep = "/"), width = 1600, height = 1200)
print(heatmap(eventHeat[,], main = paste(z, "Heat Map"),col=my_palette))
#print(heatmap(eventDF[,150:210], main = paste(z, "Heat Map")))
dev.off()
}
View(train)
events <- get(i)
if (i == "eventsTrim") {
desired_length <- length(chems)
list <- vector(mode = "list", length = desired_length)
for (y in chems){
list[[y]] <- nrow(events[grep(y, rownames(events)), ])
#dat <- nrow(events[grep(y, rownames(events)), ])
}
dsNum <- min(unlist(list))
if (dsNum <= 1){
next
}
dsData <- data.frame()
for (y in chems) {
#print(y)
idx_chem <- events[grep(y, rownames(events)), ]
idx_chem["pred"] <- as.factor(y)
data <- sample_n(idx_chem, dsNum)
dsData <- rbind(dsData, data)
}
dsData <- dsData[,c(ncol(dsData),1:(ncol(dsData)-1))]
### Need to build training and test sets ###
#this is broken...
sample = sample.split(dsData$pred, SplitRatio = .7)
train = subset(data, sample == TRUE)
test  = subset(data, sample == FALSE)
stop()
##### Naive Bayes Test ######
##### Need to balance sets ####
# nbModel <- naiveBayes(pred ~., data = dsData)
# nbPredict <- predict(nbModel, test[,-1])
# table(pred=nbPredict,true=eventDF$Event)
#
# confusionMatrix(nbPredict, eventDF$Event)
### Decision Tree ###
### also awaiting balanced sets ###
### this S#its gonna be so tight when it works ###
# tree <- rpart(pred ~ .,
#               data = dsData,
#               method = "class")
#
# rpart.plot(tree, nn=TRUE)
#
# #probably need to remove column by name instead
# treePredict <- predict(object=tree,dsData[-1],type="class")
#
# table(treePredict, dsData$pred)
#
# confusionMatrix(treePredict, dsData$pred)
}
for (i in eventList)
{
events <- get(i)
if (i == "eventsTrim") {
desired_length <- length(chems)
list <- vector(mode = "list", length = desired_length)
for (y in chems){
list[[y]] <- nrow(events[grep(y, rownames(events)), ])
#dat <- nrow(events[grep(y, rownames(events)), ])
}
dsNum <- min(unlist(list))
if (dsNum <= 1){
next
}
dsData <- data.frame()
for (y in chems) {
#print(y)
idx_chem <- events[grep(y, rownames(events)), ]
idx_chem["pred"] <- as.factor(y)
data <- sample_n(idx_chem, dsNum)
dsData <- rbind(dsData, data)
}
dsData <- dsData[,c(ncol(dsData),1:(ncol(dsData)-1))]
### Need to build training and test sets ###
#this is broken...
sample = sample.split(dsData$pred, SplitRatio = .7)
train = subset(data, sample == TRUE)
test  = subset(data, sample == FALSE)
stop()
##### Naive Bayes Test ######
##### Need to balance sets ####
# nbModel <- naiveBayes(pred ~., data = dsData)
# nbPredict <- predict(nbModel, test[,-1])
# table(pred=nbPredict,true=eventDF$Event)
#
# confusionMatrix(nbPredict, eventDF$Event)
### Decision Tree ###
### also awaiting balanced sets ###
### this S#its gonna be so tight when it works ###
# tree <- rpart(pred ~ .,
#               data = dsData,
#               method = "class")
#
# rpart.plot(tree, nn=TRUE)
#
# #probably need to remove column by name instead
# treePredict <- predict(object=tree,dsData[-1],type="class")
#
# table(treePredict, dsData$pred)
#
# confusionMatrix(treePredict, dsData$pred)
}
eventDF <- events
eventHeat <- as.matrix(eventDF)
k <- round(sqrt(nrow(eventDF)))
#print(k)
#km.res <- kmeans(eventDF, k, nstart = 25)
##########################################nstart???
if (kSwitch == TRUE){
# K-Means Cluster Analysis
km.res <- kmeans(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
} else {
# K-means with pam()
km.res <- pam(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
}
#####################################################################
# Ward Hierarchical Clustering
distance <- dist(eventDF, method = "euclidean") # distance matrix
fit <- hclust(distance, method="ward.D2")
groups <- cutree(fit, k)
# Events <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), "Events.csv", sep="-")
# write.csv(events, paste(output, Events, sep = "/"),)
dendro <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "Dendrogram.png", sep="-")
png(paste(output, dendro, sep = "/"), width = 1200, height = 600)
plot(fit, main = paste(toString(z), toString(ExpectedChange), toString(windowSize), "Dendrogram","| Clusters:", toString(k), sep=" "))
#groups <- cutree(fit, k)
rect.hclust(fit, k, border="red")
dev.off()
#km.res <- kmeans(eventDF, k, nstart = 25)
fvizclust<- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "FvizCluster.png", sep="-")
png(paste(output, fvizclust, sep = "/"), width = 800, height = 800)
print(fviz_cluster(km.res, eventDF, main = paste(z, "Cluster Plot", "| Clusters:", toString(k))))
dev.off()
#d3heatmap or heatmaply
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 300)
heatMap <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "HeatMap.png", sep="-")
png(paste(output, heatMap, sep = "/"), width = 1600, height = 1200)
print(heatmap(eventHeat[,], main = paste(z, "Heat Map"),col=my_palette))
#print(heatmap(eventDF[,150:210], main = paste(z, "Heat Map")))
dev.off()
}
for (i in eventList)
{
events <- get(i)
if (i == "eventsTrim") {
desired_length <- length(chems)
list <- vector(mode = "list", length = desired_length)
for (y in chems){
list[[y]] <- nrow(events[grep(y, rownames(events)), ])
#dat <- nrow(events[grep(y, rownames(events)), ])
}
dsNum <- min(unlist(list))
if (dsNum <= 1){
next
}
dsData <- data.frame()
for (y in chems) {
#print(y)
idx_chem <- events[grep(y, rownames(events)), ]
idx_chem["pred"] <- as.factor(y)
data <- sample_n(idx_chem, dsNum)
dsData <- rbind(dsData, data)
}
dsData <- dsData[,c(ncol(dsData),1:(ncol(dsData)-1))]
### Need to build training and test sets ###
#this is broken...
#sample = sample.split(dsData$pred, SplitRatio = .7)
#train = subset(data, sample == TRUE)
#test  = subset(data, sample == FALSE)
stop()
##### Naive Bayes Test ######
##### Need to balance sets ####
# nbModel <- naiveBayes(pred ~., data = dsData)
# nbPredict <- predict(nbModel, test[,-1])
# table(pred=nbPredict,true=eventDF$Event)
#
# confusionMatrix(nbPredict, eventDF$Event)
### Decision Tree ###
### also awaiting balanced sets ###
### this S#its gonna be so tight when it works ###
# tree <- rpart(pred ~ .,
#               data = dsData,
#               method = "class")
#
# rpart.plot(tree, nn=TRUE)
#
# #probably need to remove column by name instead
# treePredict <- predict(object=tree,dsData[-1],type="class")
#
# table(treePredict, dsData$pred)
#
# confusionMatrix(treePredict, dsData$pred)
}
eventDF <- events
eventHeat <- as.matrix(eventDF)
k <- round(sqrt(nrow(eventDF)))
#print(k)
#km.res <- kmeans(eventDF, k, nstart = 25)
##########################################nstart???
if (kSwitch == TRUE){
# K-Means Cluster Analysis
km.res <- kmeans(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
} else {
# K-means with pam()
km.res <- pam(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
}
#####################################################################
# Ward Hierarchical Clustering
distance <- dist(eventDF, method = "euclidean") # distance matrix
fit <- hclust(distance, method="ward.D2")
groups <- cutree(fit, k)
# Events <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), "Events.csv", sep="-")
# write.csv(events, paste(output, Events, sep = "/"),)
dendro <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "Dendrogram.png", sep="-")
png(paste(output, dendro, sep = "/"), width = 1200, height = 600)
plot(fit, main = paste(toString(z), toString(ExpectedChange), toString(windowSize), "Dendrogram","| Clusters:", toString(k), sep=" "))
#groups <- cutree(fit, k)
rect.hclust(fit, k, border="red")
dev.off()
#km.res <- kmeans(eventDF, k, nstart = 25)
fvizclust<- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "FvizCluster.png", sep="-")
png(paste(output, fvizclust, sep = "/"), width = 800, height = 800)
print(fviz_cluster(km.res, eventDF, main = paste(z, "Cluster Plot", "| Clusters:", toString(k))))
dev.off()
#d3heatmap or heatmaply
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 300)
heatMap <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "HeatMap.png", sep="-")
png(paste(output, heatMap, sep = "/"), width = 1600, height = 1200)
print(heatmap(eventHeat[,], main = paste(z, "Heat Map"),col=my_palette))
#print(heatmap(eventDF[,150:210], main = paste(z, "Heat Map")))
dev.off()
}
eventDF <- events
eventHeat <- as.matrix(eventDF)
k <- round(sqrt(nrow(eventDF)))
#km.res <- kmeans(eventDF, k, nstart = 25)
##########################################nstart???
if (kSwitch == TRUE){
# K-Means Cluster Analysis
km.res <- kmeans(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
} else {
# K-means with pam()
km.res <- pam(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
}
# Ward Hierarchical Clustering
distance <- dist(eventDF, method = "euclidean") # distance matrix
fit <- hclust(distance, method="ward.D2")
groups <- cutree(fit, k)
dendro <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "Dendrogram.png", sep="-")
png(paste(output, dendro, sep = "/"), width = 1200, height = 600)
plot(fit, main = paste(toString(z), toString(ExpectedChange), toString(windowSize), "Dendrogram","| Clusters:", toString(k), sep=" "))
#groups <- cutree(fit, k)
rect.hclust(fit, k, border="red")
dev.off()
#km.res <- kmeans(eventDF, k, nstart = 25)
fvizclust<- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "FvizCluster.png", sep="-")
png(paste(output, fvizclust, sep = "/"), width = 800, height = 800)
print(fviz_cluster(km.res, eventDF, main = paste(z, "Cluster Plot", "| Clusters:", toString(k))))
dev.off()
#d3heatmap or heatmaply
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 300)
heatMap <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "HeatMap.png", sep="-")
png(paste(output, heatMap, sep = "/"), width = 1600, height = 1200)
print(heatmap(eventHeat[,], main = paste(z, "Heat Map"),col=my_palette))
#print(heatmap(eventDF[,150:210], main = paste(z, "Heat Map")))
dev.off()
{
events <- get(i)
if (i == "eventsTrim") {
desired_length <- length(chems)
list <- vector(mode = "list", length = desired_length)
for (y in chems){
list[[y]] <- nrow(events[grep(y, rownames(events)), ])
#dat <- nrow(events[grep(y, rownames(events)), ])
}
dsNum <- min(unlist(list))
if (dsNum <= 1){
next
}
dsData <- data.frame()
for (y in chems) {
#print(y)
idx_chem <- events[grep(y, rownames(events)), ]
idx_chem["pred"] <- as.factor(y)
data <- sample_n(idx_chem, dsNum)
dsData <- rbind(dsData, data)
}
dsData <- dsData[,c(ncol(dsData),1:(ncol(dsData)-1))]
### Need to build training and test sets ###
#this is broken...
sample = sample.split(dsData$pred, SplitRatio = .7)
train = subset(data, sample == TRUE)
test  = subset(data, sample == FALSE)
stop()
##### Naive Bayes Test ######
##### Need to balance sets ####
# nbModel <- naiveBayes(pred ~., data = dsData)
# nbPredict <- predict(nbModel, test[,-1])
# table(pred=nbPredict,true=eventDF$Event)
#
# confusionMatrix(nbPredict, eventDF$Event)
### Decision Tree ###
### also awaiting balanced sets ###
### this S#its gonna be so tight when it works ###
# tree <- rpart(pred ~ .,
#               data = dsData,
#               method = "class")
#
# rpart.plot(tree, nn=TRUE)
#
# #probably need to remove column by name instead
# treePredict <- predict(object=tree,dsData[-1],type="class")
#
# table(treePredict, dsData$pred)
#
# confusionMatrix(treePredict, dsData$pred)
}
eventDF <- events
eventHeat <- as.matrix(eventDF)
k <- round(sqrt(nrow(eventDF)))
#print(k)
#km.res <- kmeans(eventDF, k, nstart = 25)
##########################################nstart???
if (kSwitch == TRUE){
# K-Means Cluster Analysis
km.res <- kmeans(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
} else {
# K-means with pam()
km.res <- pam(eventDF, k)
aggregate(eventDF,by=list(km.res$cluster),FUN=mean)
eventDF <- data.frame(eventDF, km.res$cluster)
}
#####################################################################
# Ward Hierarchical Clustering
distance <- dist(eventDF, method = "euclidean") # distance matrix
fit <- hclust(distance, method="ward.D2")
groups <- cutree(fit, k)
# Events <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), "Events.csv", sep="-")
# write.csv(events, paste(output, Events, sep = "/"),)
dendro <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "Dendrogram.png", sep="-")
png(paste(output, dendro, sep = "/"), width = 1200, height = 600)
plot(fit, main = paste(toString(z), toString(ExpectedChange), toString(windowSize), "Dendrogram","| Clusters:", toString(k), sep=" "))
#groups <- cutree(fit, k)
rect.hclust(fit, k, border="red")
dev.off()
#km.res <- kmeans(eventDF, k, nstart = 25)
fvizclust<- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "FvizCluster.png", sep="-")
png(paste(output, fvizclust, sep = "/"), width = 800, height = 800)
print(fviz_cluster(km.res, eventDF, main = paste(z, "Cluster Plot", "| Clusters:", toString(k))))
dev.off()
#d3heatmap or heatmaply
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 300)
heatMap <- paste(toString(Sys.Date()), toString(z), toString(ExpectedChange), toString(windowSize), toString(i), "HeatMap.png", sep="-")
png(paste(output, heatMap, sep = "/"), width = 1600, height = 1200)
print(heatmap(eventHeat[,], main = paste(z, "Heat Map"),col=my_palette))
#print(heatmap(eventDF[,150:210], main = paste(z, "Heat Map")))
dev.off()
}
source('~/MQSensor/Machine Learning/MLTest.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLTest.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLTest.R', echo=TRUE)
View(train)
View(dsData)
### Need to build training and test sets ###
#this is broken...
sample <- sample.split(dsData$pred, SplitRatio = .7)
train <- subset(dsData, sample == TRUE)
test  <- subset(dsData, sample == FALSE)
View(train)
View(test)
