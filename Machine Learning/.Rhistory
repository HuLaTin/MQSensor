source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
gg + theme(legend.position = "top")
#
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/R 2019/Homework/AnnotationLab.R', echo=TRUE)
source('~/R 2019/Homework/MiscellaneousGraphsExercise.R', echo=TRUE)
shiny::runApp('Rapp/sensorApp')
source('~/MQSensor/utility.R', echo=TRUE)
shiny::runApp('Rapp/sensorApp')
sensorPlotly
source('~/MQSensor/utility.R', echo=TRUE)
install.packages(c("rcdk", "tidyverse"))
# Let's start preparing the rcdk package
if(!require("rcdk",quietly=TRUE)) {
install.packages("rcdk", repos="https://cloud.r-project.org/",
quiet=TRUE, type="binary")
library("rcdk")
}
# These are the descriptors that can be calculated from rcdk
get.desc.names()
# To calculate the Wiener index for ethane
ethane <- parse.smiles("CC")
eval.desc(ethane,
"org.openscience.cdk.qsar.descriptors.molecular.WienerNumbersDescriptor")
# To calculate the first Zagreb indices index for pentane, 2-methylpentane and 2,3-dimethylbutane
hcs <- parse.smiles(c("CCCCC","CCCC(C)C","CC(C)C(C)C"))
eval.desc(hcs,
"org.openscience.cdk.qsar.descriptors.molecular.ZagrebIndexDescriptor")
hcsSMILES <- c("CCCCC","CCCC(C)C","CC(C)C(C)C")
write.table(data.frame(hcsSMILES), file="hcs_SMILES.smi",
row.names=FALSE, col.names=FALSE, quote=FALSE)
dfHcsDesc <- read.table(file="hcs_SMILES_desc.csv", sep=",", dec=".",
header=TRUE)
# number of descriptors
ncol(dfHcsDesc) - 1
# Wiener and Zagreb indices
dfHcsDesc[, c("name","WPath","Zagreb1","Zagreb2")]
if (!require("BiocManager", quietly=TRUE))
install.packages("BiocManager", repos="https://cloud.r-project.org/")
if (!require("ChemmineR", quietly=TRUE)) {
BiocManager::install("ChemmineR",ask=FALSE)
library("ChemmineR")
}
if (!require("ChemmineOB", quietly=TRUE)) {
BiocManager::install("ChemmineOB",ask=FALSE)
library("ChemmineOB")
}
names(hcsSMILES) <- hcsSMILES
hcsSDF <-  smiles2sdf(hcsSMILES)
hcsSDF <- generate3DCoords(hcsSDF)
write.SDF(hcsSDF, file="hcs_SDF.sdf")
dfBp <- read.table(file="BP.csv", sep=",", dec=".", header=TRUE)
dfBp
if(!require("tidyverse",quietly=TRUE)) {
install.packages("tidyverse", repos="https://cloud.r-project.org/",
quiet=TRUE, type="binary")
library("tidyverse")
}
ggplot(dfBp,aes(x=MW, y=BP_K)) +
geom_point(size=3, alpha=0.2) + theme_classic()
write.table(dfBp$SMILES, file="bp_SMILES.smi",
row.names=FALSE, col.names=FALSE, quote=FALSE)
dfBpDesc <- read.table(file="bp_desc.csv", sep=",", dec=".",
header=TRUE)
# number of descriptors
ncol(dfHcsDesc) - 1
# Add the Wiener and Zagreb indices to the data frame
# that includes the boiling points
dfBp <- data.frame(dfBp,dfBpDesc[, c("WPath","Zagreb1","Zagreb2")])
dfBp
ggplot(dfBp,aes(x=WPath, y=BP_K)) +
geom_point(size=3, alpha=0.2) + theme_classic()
ggplot(dfBp,aes(x=Zagreb1, y=BP_K)) +
geom_point(size=3, alpha=0.2) + theme_classic()
ggplot(dfBp,aes(x=Zagreb2, y=BP_K)) +
geom_point(size=3, alpha=0.2) + theme_classic()
fit1 <- lm(BP_K ~ MW, data = dfBp)
summary(fit1)
# Let's plot the results
dfBp_fit1 <- data.frame(dfBp,BP_K_pred=predict(fit1))
ggplot(dfBp_fit1, aes(x=BP_K, y=BP_K_pred)) +
geom_point(size=3, alpha=0.2) +
geom_line(aes(y=BP_K)) + theme_classic()
# Let's check the residuals
plot(fit1, which=1)
fit2 <- lm(BP_K ~ MW + log(MW), data = dfBp)
summary(fit2)
# Let's plot the results
dfBp_fit2 <- data.frame(dfBp,BP_K_pred=predict(fit2))
ggplot(dfBp_fit2, aes(x=BP_K, y=BP_K_pred)) +
geom_point(size=3, alpha=0.2) +
geom_line(aes(y=BP_K)) + theme_classic()
# Let's check the residuals
plot(fit2, which=1)
fit3 <- lm(BP_K ~ MW + log(MW) + WPath + Zagreb1 + Zagreb2, data = dfBp)
summary(fit3)
# Let's plot the results
dfBp_fit3 <- data.frame(dfBp,BP_K_pred=predict(fit3))
ggplot(dfBp_fit3, aes(x=BP_K, y=BP_K_pred)) +
geom_point(size=3, alpha=0.2) +
geom_line(aes(y=BP_K)) + theme_classic()
# Let's check the residuals
plot(fit3, which=1)
source("http://bioconductor.org/biocLite.R")
biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
BiocManager::biocLite
#source("http://bioconductor.org/biocLite.R")
#BiocManager::biocLite
library(biocLite)
#source("http://bioconductor.org/biocLite.R")
#BiocManager::biocLite
library ("ShortRead")
biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
library ("biocLite")
source("http://bioconductor.org/biocLite.R")
library("Bioconductor")
source("http://bioconductor.org/biocLite.R")
BiocManager::install(version = "3.10")
library(MotifDb)
library(seqLogo)
library(motifStack)
library(Biostrings)
library(GenomicFeatures)
library(org.Sc.sgd.db)
library(BSgenome.Scerevisiae.UCSC.sacCer3)
library(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)
query(MotifDb, "DAL80")
library (bioclite)
source("http://bioconductor.org/biocLite.R")
source("http://bioconductor.org/biocLite.R")
BiocManager::install(version = "3.10")
BiocManager::install(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
library(MotifDb)
library(seqLogo)
library(motifStack)
library(Biostrings)
library(GenomicFeatures)
library(org.Sc.sgd.db)
library(BSgenome.Scerevisiae.UCSC.sacCer3)
library(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)
query(MotifDb, "DAL80")
pfm.dal80.jaspar <- query(MotifDb,"DAL80")[[1]]
seqLogo(pfm.dal80.jaspar)
biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
source("http://bioconductor.org/biocLite.R")
BiocManager::install(version = "3.10")
source('~/R 2019/Bioinformatics Theory and Apps/RegulatoryElementsLab/RegulatoryElementsLab.R', echo=TRUE)
source('~/R 2019/Bioinformatics Theory and Apps/RegulatoryElementsLab/RegulatoryElementsLab.R', echo=TRUE)
source('~/R 2019/Bioinformatics Theory and Apps/RegulatoryElementsLab/RegulatoryElementsLab.R', echo=TRUE)
biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
BiocManager::biocLite
source("biocLite")
library(biocLite)
source("http://bioconductor.org/biocLite.R")
BiocManager::biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
install
BiocManager::install(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
biocLite(c("MotifDb", "GenomicFeatures",
"TxDb.Scerevisiae.UCSC.sacCer3.sgdGene",
"org.Sc.sgd.db", "BSgenome.Scerevisiae.UCSC.sacCer3",
"motifStack", "seqLogo"))
library(MotifDb)
library(seqLogo)
source('~/R 2019/Bioinformatics Theory and Apps/RegulatoryElementsLab/RegulatoryElementsLab.R', echo=TRUE)
source('~/R 2019/Bioinformatics Theory and Apps/RegulatoryElementsLab/RegulatoryElementsLab.R', echo=TRUE)
source('~/Machine Learning/MachineLearning.R', echo=TRUE)
setwd("~/Machine Learning")
source('~/Machine Learning/MLFinal.R', echo=TRUE)
View(events)
#set seed so events are reproducible
set.seed(2357)
#clusters <- kmeans(events[], k)
clusters <- kmeans(events[], 3)
#data points in each group
clusters$size
events$cluster <- clusters$cluster
table(events$cluster)
#(?)
events.feature = as.matrix(events)
#Dendrogram
hc <- hclust(dist(events.feature), "ave")
plot(hc, hang = -1)
#Heatmap
library(gplots)
library(RColorBrewer )
my_palette <- colorRampPalette(c("green", "black", "red"))(n = 1000)
heatmap.2(events.feature,col=my_palette, dendrogram = "row", trace = "none", key = 5,
cexCol = .8, margin = c(4,4), cexRow = .5, symbreaks = FALSE)
#set seed so events are reproducible
set.seed(2357)
#clusters <- kmeans(events[], k)
clusters <- kmeans(events[], 7)
#data points in each group
clusters$size
events$cluster <- clusters$cluster
table(events$cluster)
#(?)
events.feature = as.matrix(events)
#Dendrogram
hc <- hclust(dist(events.feature), "ave")
plot(hc, hang = -1)
#Heatmap
library(gplots)
library(RColorBrewer )
my_palette <- colorRampPalette(c("green", "black", "red"))(n = 1000)
heatmap.2(events.feature,col=my_palette, dendrogram = "row", trace = "none", key = 5,
cexCol = .8, margin = c(4,4), cexRow = .5, symbreaks = FALSE)
eventTemp <- data.frame()
events <- data.frame(matrix(NA, nrow = 50))
events <- events[-c(1)]
numEvents = nrow(eventsCaptured)/50
for (eventNum in 1:numEvents){
eventStart = (50 * (eventNum - 1)) + 1
eventStop = (50 * eventNum)
eventTemp <- as.data.frame(eventsCaptured[eventStart:eventStop,])
eventTemp["num"] <- seq(length=nrow(eventTemp))
eventTemp <- melt(eventTemp, id=c("Time","num"))
eventTemp["num"] <- seq(length=nrow(eventTemp))
events <- cbind(events, eventTemp[,4])
names(events)[c(ncol(events))] <- paste("Event", toString(eventNum), sep=" ")
}
#set seed so events are reproducible
set.seed(2357)
#clusters <- kmeans(events[], k)
clusters <- kmeans(events[], 7)
#data points in each group
clusters$size
events$cluster <- clusters$cluster
table(events$cluster)
#(?)
events.feature = as.matrix(events)
#Dendrogram
hc <- hclust(dist(events.feature), "ave")
plot(hc, hang = -1)
#Heatmap
library(gplots)
library(RColorBrewer )
my_palette <- colorRampPalette(c("green", "black", "red"))(n = 1000)
heatmap.2(events.feature,col=my_palette, dendrogram = "row", trace = "none", key = 5,
cexCol = .8, margin = c(4,4), cexRow = .5, symbreaks = FALSE)
eventTemp <- data.frame()
events <- data.frame(matrix(NA, nrow = 50))
events <- events[-c(1)]
numEvents = nrow(eventsCaptured)/50
for (eventNum in 1:numEvents){
eventStart = (50 * (eventNum - 1)) + 1
eventStop = (50 * eventNum)
eventTemp <- as.data.frame(eventsCaptured[eventStart:eventStop,])
eventTemp["num"] <- seq(length=nrow(eventTemp))
eventTemp <- melt(eventTemp, id=c("Time","num"))
eventTemp["num"] <- seq(length=nrow(eventTemp))
events <- cbind(events, eventTemp[,4])
names(events)[c(ncol(events))] <- paste("Event", toString(eventNum), sep=" ")
}
#normalize
events[,1:ncol(events)] <- as.data.frame(lapply(events[,1:ncol(events)], normalize))
View(events)
eventTemp <- data.frame()
events <- data.frame(matrix(NA, nrow = 50))
events <- events[-c(1)]
numEvents = nrow(eventsCaptured)/50
for (eventNum in 1:numEvents){
eventStart = (50 * (eventNum - 1)) + 1
eventStop = (50 * eventNum)
eventTemp <- as.data.frame(eventsCaptured[eventStart:eventStop,])
eventTemp["num"] <- seq(length=nrow(eventTemp))
eventTemp <- melt(eventTemp, id=c("Time","num"))
eventTemp["num"] <- seq(length=nrow(eventTemp))
events <- cbind(events, eventTemp[,4])
names(events)[c(ncol(events))] <- paste("Event", toString(eventNum), sep=" ")
}
View(events)
#normalize
events[,1:ncol(events)] <- as.data.frame(lapply(events[,1:ncol(events)], normalize))
View(events)
events <- as.data.frame(t(events))
#normalize
print("the 'events' data frame will be normalized and transposed")
#transpose events dataframe
events <- as.data.frame(t(events))
#set seed so events are reproducible
set.seed(2357)
#clusters <- kmeans(events[], k)
clusters <- kmeans(events[], 7)
#data points in each group
clusters$size
events$cluster <- clusters$cluster
table(events$cluster)
#(?)
events.feature = as.matrix(events)
#Dendrogram
hc <- hclust(dist(events.feature), "ave")
plot(hc, hang = -1)
eventTemp <- data.frame()
events <- data.frame(matrix(NA, nrow = 50))
events <- events[-c(1)]
numEvents = nrow(eventsCaptured)/50
for (eventNum in 1:numEvents){
eventStart = (50 * (eventNum - 1)) + 1
eventStop = (50 * eventNum)
eventTemp <- as.data.frame(eventsCaptured[eventStart:eventStop,])
eventTemp["num"] <- seq(length=nrow(eventTemp))
eventTemp <- melt(eventTemp, id=c("Time","num"))
eventTemp["num"] <- seq(length=nrow(eventTemp))
events <- cbind(events, eventTemp[,4])
names(events)[c(ncol(events))] <- paste("Event", toString(eventNum), sep=" ")
}
#normalize
print("The 'events' data frame will be normalized and transposed.")
events[,1:ncol(events)] <- as.data.frame(lapply(events[,1:ncol(events)], normalize))
events <- as.data.frame(t(events))
#set seed so events are reproducible
set.seed(2357)
#clusters <- kmeans(events[], k)
clusters <- kmeans(events[], 7)
#data points in each group
clusters$size
events$cluster <- clusters$cluster
table(events$cluster)
#(?)
events.feature = as.matrix(events)
#Dendrogram
hc <- hclust(dist(events.feature), "ave")
plot(hc, hang = -1)
View(EventIndex)
View(SensorData)
View(SensorData)
View(eventsCaptured)
View(eventsCaptured)
View(events)
View(SensorData)
View(eventsCaptured)
View(SensorData)
eventTemp <- data.frame()
events <- data.frame(matrix(NA, nrow = 50))
events <- events[-c(1)]
numEvents = nrow(eventsCaptured)/50
for (eventNum in 1:numEvents){
eventStart = (50 * (eventNum - 1)) + 1
eventStop = (50 * eventNum)
eventTemp <- as.data.frame(eventsCaptured[eventStart:eventStop,])
eventTemp["num"] <- seq(length=nrow(eventTemp))
eventTemp <- melt(eventTemp, id=c("Time","num"))
eventTemp["num"] <- seq(length=nrow(eventTemp))
events <- cbind(events, eventTemp[,4])
names(events)[c(ncol(events))] <- paste("Event", toString(eventNum), sep=" ")
}
events <- as.data.frame(t(events))
rownames(events) <- c("1-Acetone", "2-Ethanol", "3-Acetone", "4-Ethanol", "5-Acetone", "6-Acetone",
"7-Ethanol", "8-Acetone", "9-Ethanol", "10-Acetone", "11-Ethanol", "12-Acetone",
"13-Unknown", "14-Unknown", "15-Ethanol", "16-Unknown", "17-Unknown", "18-Unknown",
"19-Unknown", "20-Unknown", "21-Unknown", "22-Unknown", "23-Ethanol", "24-Ethanol",
"25-Unknown", "26-Ethanol", "27-Unknown", "28-Ethanol", "29-Ethanol", "30-Ethanol",
"31-Ethanol", "32-Ethanol", "33-Ethanol", "34-Unknown", "35-Ethanol", "36-Cyclohexane",
"37-Cyclohexane", "38-Cyclohexane", "39-Cyclohexane", "40-Unknown", "41-Cyclohexane",
"42-Cyclohexane", "43-Unknown", "44-Unknown", "45-Unknown", "46-Unknown", "47-Unknown")
View(events)
#set seed so events are reproducible
set.seed(2357)
#clusters <- kmeans(events[], k)
clusters <- kmeans(events[], 7)
#data points in each group
clusters$size
events$cluster <- clusters$cluster
table(events$cluster)
#(?)
events.feature = as.matrix(events)
#Dendrogram
hc <- hclust(dist(events.feature), "ave")
plot(hc, hang = -1)
#Choose your file
SensorData <- read.csv(file.choose(), header=FALSE, sep=",")
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
View(SensorData)
View(`MQ2 ADC Events`)
View(`MQ2 ADC Index`)
View(`MQ2 ADC Times`)
View(`MQ2 ADC Times`)
View(`MQ4 ADC Captured`)
# K-Means Cluster Analysis
kclustering <- kmeans(events, 3)
View(events)
# K-Means Cluster Analysis
kclustering <- kmeans(events, 3)
View(SensorData)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
View(`MQ135 ADC Events`)
View(`MQ135 ADC Events`)
View(`MQ135 ADC Captured`)
View(eventTemp)
View(SensorData)
View(`MQ9 ADC Times`)
View(`MQ9 ADC Index`)
View(`MQ135 ADC Index`)
View(`MQ9 ADC Times`)
View(`MQ9 ADC Events`)
View(`MQ8 ADC Events`)
View(`MQ8 ADC Events`)
View(SensorData)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
View(`MQ7 ADC Events`)
View(eventsCaptured)
View(eventTemp)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
View(eventsCaptured)
View(`MQ135 ADC Times`)
View(`MQ135 ADC Events`)
View(eventTemp)
View(`MQ2 ADC Events`)
print("Program Completed!" + toString(total.time))
print("Program Completed!" + paste(toString(total.time)))
print("Program Completed!" + total.time
print("Program Completed!" + total.time)
print("Program Completed!")
print("Program Completed!")
print("Program Completed!" + total.time)
print("Program Completed!" + toString(total.time))
print("Program Completed!") + print(total.time)
print("Program Completed!") + print("completed in" total.time)
print("Program Completed!") + print("completed in" + total.time)
print("Program Completed!") + print(total.time)
print("Program Completed!") + print(total.time)
print("Program Completed!") + print(total.time)
print("Program Completed!") + print(total.time)
print("Program Completed!") + print (total.time)
print("Program Completed!") , print(total.time)
print("Program Completed!") + print(total.time)
print("Program Completed!")
print(total.time)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
View(`MQ2 ADC Index`)
View(SensorData)
View(`MQ2 ADC Index`)
View(`MQ2 ADC Times`)
View(TimeIndex)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
source('~/MQSensor/Machine Learning/MLWIP.R', echo=TRUE)
View(TimeIndex)
